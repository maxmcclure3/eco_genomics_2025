---
title: "DEseq2"
output: html_document
date: "2025-10-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "~/projects/eco_genomics_2025/transcriptomics/mydata")
library(DESeq2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(readr)
library(vsn)  
library(pheatmap)
library(vsn)

# Import the counts matrix
countsTable <- read.table("~/projects/eco_genomics_2025/transcriptomics/mydata/counts_matrix.txt", header = TRUE, row.names = 1)

head(countsTable)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
head(countsTableRound)

#import the sample description table
conds <- read.delim("~/projects/eco_genomics_2025/transcriptomics/mydata/metadata.txt", header = TRUE, stringsAsFactors = TRUE, row.names = 1)
head(conds)
```


```{r}
####################################################

### Explore data distributions

####################################################

# Let's see how many reads we have from each sample
colSums(countsTableRound)
mean(colSums(countsTableRound))

barplot(colSums(countsTableRound), 
        names.arg = colnames(countsTableRound), 
        cex.names = 0.5, las = 3, 
        ylim = c(0, 21000000)) #change dims
abline(h = mean(colSums(countsTableRound)), 
       col = "blue", lwd = 2)

# the average number of counts per gene
rowSums(countsTableRound)
mean(rowSums(countsTableRound)) # 
median(rowSums(countsTableRound)) #

apply(countsTableRound, 2, mean) # 2 in the apply function does the action across columns
apply(countsTableRound, 1, mean) # 1 in the apply function does the action across rows
hist(apply(countsTableRound, 1, mean), 
     xlim = c(0, 1000), 
     ylim = c(0, 1000), 
     breaks = 500000)


```

```{r}
####################################################

### Start working with DESeq2!

####################################################

#### Create a DESeq object and define the experimental design here with the tilda

colnames(countsTableRound) <- substr(colnames(countsTableRound), 
                                     start = 1, 
                                     stop = 4)
dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData = conds, 
                              design = ~ generation + line + generation:line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 
# How many transcripts have at least 15 reads (a.k.a counts) in 75% of the samples

# Run the DESeq model to test for differential gene expression
dds <- DESeq(dds)

# List the results you've generated
resultsNames(dds)
# Copy the results names 
```

```{r}
####################################################

### Check the quality of the data by sample clustering and visualization

####################################################

# The goal of transformation "is to remove the dependence of the variance on the mean, particularly the high variance of the logarithm of count data when the mean is low."

#library("pheatmap")
#library("vsn")

# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))

# Variance stabilizing transformation
vsd <- vst(dds, blind=FALSE)
meanSdPlot(assay(vsd))


sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$line, vsd$generation, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# Note any outliers

###############################################################

# PCA to visualize global gene expression patterns

# first transform the data for plotting using variance stabilization
vsd <- vst(dds, blind=FALSE)

pcaData <- plotPCA(vsd, intgroup=c("line","generation"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData,"percentVar"))

ggplot(pcaData, aes(PC1, PC2, color=line, shape=generation)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
```

